# -*- coding: utf-8 -*-
"""
this code for creating Young Diagrams by Sn
"""


from conf.cgc_config import default_s_n


def calc_young_diagrams(s_n=default_s_n):
    """
    杨图的计算程序：
    根据给定的Sn，计算全部杨图的配分，并返回
    （法五：首行数字循环，后面不递归了，而是读取前面的结果）

    例如S3: [[3], [2, 1], [1, 1, 1]]
    例如S6: [[6], [5, 1], [4, 2], [4, 1, 1], [3, 3], [3, 2, 1], [3, 1, 1, 1],
            [2, 2, 2], [2, 2, 1, 1], [2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]
    注意：排序按照金牌模式而不是行数，例如[3, 3]两行排在了[4, 1, 1]后面
    """
    ...


def save_young_diagrams():
    """
    杨图的落盘格式为：
    young_diagrams/Sn.type，内容为[[gamma_i], ...]

    例如：
    young_diagrams/S3.pkl: [[3], [2, 1], [1, 1, 1]]
    young_diagrams/S4.txt: [[4], [3, 1], [2, 2], [2, 1, 1], [1, 1, 1, 1]]
    """
    pass


"""
备选算法：
法一：
按照行数循环（太多if）
法二：
按照首行数字大小递归（还行，就是循环深度随着n线性增大，计算量平方增大）（好处是无需再做排序）
法三：
排列组合（利用python内置函数itertools，可能 可能 可能计算得快）
法四：
倒序生长（不如直接用分支律呢）
法五：
首行数字循环，后面不递归了，而是读取前面的结果（机智啊！io开销并不大，因为只需读取Sn个，
并且，第二行的，前面必然有结果了，不需要递归了，循环深度===2）
"""

